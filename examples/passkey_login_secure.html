<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Passkey Login (Secure)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .login-container {
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .passkey-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 6px;
            font-size: 16px;
            cursor: pointer;
            width: 100%;
            margin: 20px 0;
            transition: all 0.3s ease;
        }
        .passkey-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        .passkey-button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            text-align: center;
        }
        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .user-info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
        }
        .security-note {
            background: #d4edda;
            padding: 15px;
            border-radius: 6px;
            margin: 20px 0;
            border: 1px solid #c3e6cb;
        }
        code {
            background: #f4f4f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .config-grid {
            display: grid;
            gap: 8px;
            margin-bottom: 15px;
        }
        .config-item {
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
        }
        #config-display {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }
        #config-display h3 {
            margin-top: 0;
            color: #495057;
        }
        #config-display h4 {
            margin-bottom: 10px;
            color: #6c757d;
        }
        #config-display ul {
            margin: 0;
            padding-left: 20px;
        }
    </style>
</head>
<body>
    <div class="login-container">
        <h1>üîê Secure Passkey Login</h1>
        <p>This version uses a secure server-side authentication proxy. Your API key never leaves the server.</p>
        
        <div class="security-note">
            <h3>üõ°Ô∏è Security Features</h3>
            <ul>
                <li>‚úÖ API key stored securely on server</li>
                <li>‚úÖ No sensitive data exposed to browser</li>
                <li>‚úÖ Server-side credential verification</li>
                <li>‚úÖ CORS protection enabled</li>
            </ul>
        </div>
        
        <!-- Traditional Login Form to trigger 1Password extension -->
        <form id="loginForm" name="loginForm" action="#" method="post" style="margin-bottom: 30px;">
            <div style="margin-bottom: 15px;">
                <label for="amember_login" style="display: block; margin-bottom: 5px; font-weight: bold; color: #495057;">Username/Email</label>
                <input type="email" 
                       id="amember_login" 
                       name="amember_login" 
                       autocomplete="username email"
                       placeholder="Enter your email"
                       style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 5px; font-size: 16px; box-sizing: border-box;"
                       data-1p-ignore="false"
                       required>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label for="amember_pass" style="display: block; margin-bottom: 5px; font-weight: bold; color: #495057;">Password</label>
                <input type="password" 
                       id="amember_pass" 
                       name="amember_pass" 
                       autocomplete="current-password"
                       placeholder="Enter your password"
                       style="width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 5px; font-size: 16px; box-sizing: border-box;"
                       data-1p-ignore="false"
                       required>
            </div>
            
            <button type="submit" style="width: 100%; padding: 12px; background-color: #007cba; color: white; border: none; border-radius: 5px; font-size: 16px; cursor: pointer; margin-bottom: 15px;">
                Login
            </button>
        </form>
        
        <div style="text-align: center; margin: 20px 0; color: #666; font-weight: bold;">
            - OR -
        </div>

        <div id="status"></div>
        
        <button id="passkeyLogin" class="passkey-button">
            üîë Sign in with Passkey
        </button>
        
        <div style="margin-top: 15px;">
            <details>
                <summary style="cursor: pointer; color: #6c757d; font-size: 14px;">
                    üíª Desktop 1Password troubleshooting
                </summary>
                <div style="margin-top: 10px; padding: 15px; background: #f8f9fa; border-radius: 6px; font-size: 14px;">
                    <p><strong>If 1Password doesn't respond on desktop:</strong></p>
                    <ol>
                        <li>Make sure 1Password browser extension is enabled</li>
                        <li>Try refreshing the page and clicking login again</li>
                        <li>Check if other browser extensions are interfering</li>
                        <li>Try in an incognito/private window</li>
                        <li><strong>Mobile workaround:</strong> Open this page on your phone and scan the QR code</li>
                    </ol>
                    <p style="margin-top: 10px; color: #6c757d;"><em>Note: Mobile passkey authentication is generally more reliable than desktop browser extensions.</em></p>
                </div>
            </details>
        </div>
        
                <div id="user-info" class="user-info" style="display: none;">
            <!-- User authentication result will be displayed here -->
        </div>

        <!-- Configuration Display -->
        <div id="config-display">
            <!-- aMember WebAuthn configuration will be displayed here -->
        </div>
    </div>
        
        <div style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #eee;">
            <h3>How it works:</h3>
            <ol>
                <li>Click "Sign in with Passkey" to trigger WebAuthn authentication</li>
                <li>Browser prompts for biometric/device authentication</li>
                <li>Credential is sent to secure server-side proxy</li>
                <li>Server forwards request to aMember with protected API key</li>
                <li>aMember verifies credential and returns user information</li>
            </ol>
            
            <h4>Security Architecture:</h4>
            <p><code>Frontend ‚Üí secure_passkey_auth.php ‚Üí aMember API</code></p>
            <p>API key remains secure on server, never exposed to client.</p>
            
            <h4>Setup Required:</h4>
            <ul>
                <li>Configure <code>config.php</code> with your aMember URL and API key</li>
                <li>Ensure <code>secure_passkey_auth.php</code> is accessible via web server</li>
                <li>API key needs "by-login-pass" permission in aMember</li>
            </ul>
        </div>
    </div>

    <script>
        // Configuration - secure endpoint that handles API key server-side
        const SECURE_AUTH_ENDPOINT = './secure_passkey_auth.php';
        
        // DOM Elements
        const statusDiv = document.getElementById('status');
        const loginButton = document.getElementById('passkeyLogin');
        const userInfoDiv = document.getElementById('user-info');
        
        // Configuration will be loaded from server
        let passkeyConfig = null;
        
        // Platform detection for better user guidance
        function getPlatformInfo() {
            const userAgent = navigator.userAgent;
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
            const isDesktop = !isMobile;
            const isChrome = /Chrome/.test(userAgent);
            const isSafari = /Safari/.test(userAgent) && !/Chrome/.test(userAgent);
            const isFirefox = /Firefox/.test(userAgent);
            
            return {
                isMobile,
                isDesktop,
                isChrome,
                isSafari,
                isFirefox,
                userAgent
            };
        }
        
        // Enhanced status function with platform-specific messages
        function showStatus(message, type = 'info') {
            const platform = getPlatformInfo();
            statusDiv.innerHTML = message;
            statusDiv.className = type;
            
            // Add platform-specific hints for desktop users
            if (platform.isDesktop && (message.includes('Please authenticate') || message.includes('üëÜ'))) {
                const hint = platform.isChrome ? 
                    '<br><small>üí° Chrome + 1Password: Make sure the browser extension is enabled</small>' :
                    platform.isSafari ?
                    '<br><small>üí° Safari: Built-in passkey support should work automatically</small>' :
                    '<br><small>üí° If nothing happens, try scanning this page with your phone</small>';
                statusDiv.innerHTML += hint;
            }
        }
        
        // Utility function to display user information
        function displayUserInfo(userData) {
            const userInfoDiv = document.getElementById('user-info');
            if (!userInfoDiv) {
                console.error('user-info div not found');
                return;
            }
            
            userInfoDiv.innerHTML = `
                <h3>‚úÖ Authentication Successful!</h3>
                <div class="user-details">
                    <p><strong>User ID:</strong> ${userData.user_id || 'N/A'}</p>
                    <p><strong>Name:</strong> ${userData.name || 'N/A'}</p>
                    <p><strong>Email:</strong> ${userData.email || 'N/A'}</p>
                    <p><strong>Access:</strong> ${userData.access ? 'Granted' : 'Denied'}</p>
                </div>
            `;
            userInfoDiv.style.display = 'block';
        }
        
        // Base64URL encoding/decoding utilities
        function base64urlToBase64(str) {
            return str.replace(/-/g, '+').replace(/_/g, '/').padEnd(str.length + (4 - str.length % 4) % 4, '=');
        }
        
        function base64ToBase64url(str) {
            return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }
        
        function arrayBufferToBase64url(buffer) {
            return base64ToBase64url(btoa(String.fromCharCode(...new Uint8Array(buffer))));
        }
        
        // Check if 1Password extension is available and responsive
        async function checkOnePasswordAvailability() {
            console.log('üîç Checking 1Password extension availability...');
            
            // Check 1: Basic extension detection via DOM
            const extensionMarkers = [
                'data-onepassword-extension-id',
                'data-1p-extension',
                '[data-onepassword]',
                '.onepassword-extension'
            ];
            
            let domMarkers = 0;
            extensionMarkers.forEach(marker => {
                if (document.querySelector(marker)) {
                    domMarkers++;
                    console.log(`‚úÖ Found 1Password DOM marker: ${marker}`);
                }
            });
            
            // Check 2: Look for 1Password-injected elements
            const onePasswordElements = document.querySelectorAll('[id*="onepassword"], [class*="onepassword"], [data*="onepassword"]');
            console.log(`Found ${onePasswordElements.length} 1Password-related DOM elements`);
            
            // Check 3: Test WebAuthn availability 
            const webauthnSupported = !!(navigator.credentials && navigator.credentials.create && navigator.credentials.get);
            console.log('WebAuthn API supported:', webauthnSupported);
            
            // Check 4: User agent detection (less reliable but useful for logging)
            const userAgent = navigator.userAgent;
            const isChrome = userAgent.includes('Chrome');
            const isSafari = userAgent.includes('Safari') && !userAgent.includes('Chrome');
            const isFirefox = userAgent.includes('Firefox');
            
            console.log(`Browser: ${isChrome ? 'Chrome' : isSafari ? 'Safari' : isFirefox ? 'Firefox' : 'Other'}`);
            console.log('User Agent:', userAgent);
            
            return {
                webauthnSupported,
                domMarkers,
                onePasswordElements: onePasswordElements.length,
                browser: { isChrome, isSafari, isFirefox },
                likely1PasswordPresent: domMarkers > 0 || onePasswordElements.length > 0
            };
        }
        
        // Load passkey configuration from server
        async function loadPasskeyConfig() {
            try {
                showStatus('üîÑ Loading configuration from aMember...', 'info');
                
                const response = await fetch(SECURE_AUTH_ENDPOINT + '?action=config');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const config = await response.json();
                if (!config.ok) {
                    throw new Error(config.error || 'Failed to load configuration');
                }
                
                passkeyConfig = config;
                showStatus('‚úÖ Configuration loaded from aMember!', 'success');
                
                // Display the configuration settings for debugging
                displayConfigurationSettings(config);
                
                return true;
                
            } catch (error) {
                console.error('Configuration loading error:', error);
                showStatus(`‚ùå Failed to load configuration: ${error.message}`, 'error');
                return false;
            }
        }
        
        // Main passkey authentication function
        async function authenticateWithPasskey() {
            try {
                // CRITICAL: Preserve user gesture context - do minimal checks first
                console.log('üöÄ Button clicked - preserving user gesture context');
                
                // Basic WebAuthn support check (synchronous)
                if (!window.PublicKeyCredential) {
                    throw new Error('WebAuthn is not supported in this browser');
                }
                
                if (!navigator.credentials || !navigator.credentials.get) {
                    throw new Error('WebAuthn credentials API not available');
                }
                
                showStatus('üîë Starting authentication - preserving click context...');
                loginButton.disabled = true;
                
                // Use cached config if available, otherwise use defaults to preserve user gesture
                const config = passkeyConfig || {
                    rpId: 'www.kumpeapps.com',
                    timeout: 60000,
                    userVerification: 'preferred'
                };
                
                // Create authentication options immediately (synchronous)
                const authOptions = {
                    challenge: crypto.getRandomValues(new Uint8Array(32)),
                    timeout: parseInt(config.timeout) || 60000,
                    rpId: String(config.rpId || 'www.kumpeapps.com'),
                    userVerification: String(config.userVerification || 'preferred'),
                    allowCredentials: []  // Empty for discoverable credentials
                };
                
                console.log('üéØ About to call navigator.credentials.get for MANUAL authentication...');
                console.log('üîß navigator.credentials available:', !!navigator.credentials);
                console.log('üîß navigator.credentials.get available:', typeof navigator.credentials.get);
                
                // CRITICAL: Call WebAuthn immediately while user gesture is still active
                const webauthnPromise = navigator.credentials.get({
                    publicKey: authOptions
                    // NO mediation parameter for manual authentication - this is user-initiated
                });
                
                console.log('üöÄ Manual WebAuthn promise created, waiting for response...');
                
                // Race against timeout to detect hanging
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('MANUAL WebAuthn call timed out after 10 seconds')), 10000);
                });
                
                let credential;
                try {
                    credential = await Promise.race([webauthnPromise, timeoutPromise]);
                    console.log('‚úÖ Manual WebAuthn success! Credential received:', credential?.id || 'unknown');
                } catch (raceError) {
                    console.error('üö® Manual WebAuthn race error:', raceError.message);
                    // Try to get the original promise result anyway
                    try {
                        console.log('üîÑ Attempting to resolve original manual promise...');
                        credential = await webauthnPromise;
                        console.log('‚úÖ Late manual WebAuthn success:', credential?.id || 'unknown');
                    } catch (originalError) {
                        console.error('üí• Original manual WebAuthn error:', originalError);
                        throw originalError;
                    }
                }
                
                // Now do the post-authentication processing (config loading can happen here)
                if (!passkeyConfig) {
                    console.log('üîÑ Loading full configuration after authentication...');
                    await loadPasskeyConfig();
                }
                
                // Process the successful credential
                showStatus('üì° Verifying passkey credential...');
                
                const credentialData = {
                    id: credential.id,
                    rawId: arrayBufferToBase64url(credential.rawId),
                    type: credential.type,
                    response: {
                        clientDataJSON: arrayBufferToBase64url(credential.response.clientDataJSON),
                        authenticatorData: arrayBufferToBase64url(credential.response.authenticatorData),
                        signature: arrayBufferToBase64url(credential.response.signature),
                        userHandle: credential.response.userHandle ? 
                            arrayBufferToBase64url(credential.response.userHandle) : null
                    },
                    challenge: arrayBufferToBase64url(authOptions.challenge)
                };
                
                console.log('üì¶ Credential data prepared:', {
                    id: credentialData.id,
                    type: credentialData.type,
                    hasUserHandle: !!credentialData.response.userHandle
                });
                
                // Send to server for verification
                const verifyResponse = await fetch('secure_passkey_auth.php', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': passkeyConfig?.apiKey || ''
                    },
                    body: JSON.stringify({
                        action: 'verify',
                        credential: credentialData
                    })
                });
                
                if (!verifyResponse.ok) {
                    throw new Error(`Verification failed: ${verifyResponse.status} ${verifyResponse.statusText}`);
                }
                
                const result = await verifyResponse.json();
                
                if (result.success) {
                    showStatus(`‚úÖ Authentication successful! Welcome ${result.user?.name || result.user?.login || 'user'}!`, 'success');
                    console.log('üéâ Authentication complete:', result);
                } else {
                    throw new Error(result.error || 'Authentication verification failed');
                }
                
            } catch (error) {
                console.error('‚ùå WebAuthn error:', error);
                console.error('Error details:', {
                    name: error.name,
                    message: error.message,
                    stack: error.stack
                });
                
                // Enhanced 1Password-specific error handling  
                if (error.name === 'NotAllowedError') {
                    showStatus('‚ùå Authentication cancelled or no passkey available. Please try again or use mobile device.', 'error');
                } else if (error.message?.includes('timeout')) {
                    showStatus('‚ùå Authentication timed out. Please try again.', 'error');
                } else {
                    showStatus(`‚ùå Authentication failed: ${error.message}`, 'error');
                }
            } finally {
                loginButton.disabled = false;
            }
        }
                
        // Desktop optimization function
        async function performDesktopOptimizedAuth() {
                // Desktop optimization: Longer delay for 1Password to be ready
                console.log('Desktop compatibility: Adding delay for 1Password readiness...');
                await new Promise(resolve => setTimeout(resolve, 250));
                
                showStatus('üîë Requesting passkey authentication...');
                loginButton.disabled = true;
                
                // For desktop 1Password compatibility, try to get actual credential IDs first
                let allowCredentials = [];
                
                // CRITICAL FIX: Based on aMember plugin analysis
                // Regular users should use EMPTY allowCredentials (discoverable credentials mode)
                // Only admin users need specific credential IDs
                console.log('üîß Using aMember-compatible credential discovery mode');
                console.log('Setting allowCredentials to EMPTY array for discoverable credentials (like aMember does for regular users)');
                
                // Skip credential loading for regular users - use discoverable credentials mode
                // This matches aMember plugin behavior: empty allowCredentials for users, specific IDs only for admins
                
                // Create authentication options using server configuration
                const authOptions = {
                    challenge: crypto.getRandomValues(new Uint8Array(32)),
                    timeout: parseInt(passkeyConfig.timeout) || 60000,
                    // Use aMember's configured rpId (this should match where credentials were registered)
                    rpId: String(passkeyConfig.rpId || window.location.hostname),
                    userVerification: String(passkeyConfig.userVerification || 'preferred'),
                    // CRITICAL: Use empty allowCredentials for discoverable credentials (matches aMember behavior)
                    allowCredentials: allowCredentials  // This should be empty array []
                };
                
                // DO NOT add authenticatorSelection for regular users (matches aMember plugin behavior)
                // aMember plugin only uses specific credentials for admin users, not regular users
                console.log('üîÑ Using discoverable credentials mode (empty allowCredentials) - matches aMember plugin behavior for regular users');
                
                // Validate authOptions before use
                if (!authOptions.challenge || authOptions.challenge.length !== 32) {
                    throw new Error('Invalid challenge generated');
                }
                if (!authOptions.rpId || typeof authOptions.rpId !== 'string') {
                    throw new Error('Invalid rpId configuration');
                }
                if (!Array.isArray(authOptions.allowCredentials)) {
                    throw new Error('Invalid allowCredentials format');
                }
                
                console.log('WebAuthn auth options:', authOptions);
                
                // Debug: Show what we're asking for
                console.log('üîç Authentication Request Details:');
                console.log('- RP ID:', authOptions.rpId);
                console.log('- Current domain:', window.location.hostname);
                console.log('- Cross-domain?', authOptions.rpId !== window.location.hostname);
                console.log('- Challenge length:', authOptions.challenge.byteLength);
                console.log('- Timeout:', authOptions.timeout);
                console.log('- User verification:', authOptions.userVerification);
                console.log('- Allow credentials count:', authOptions.allowCredentials.length);
                if (authOptions.allowCredentials.length > 0) {
                    console.log('- Desktop 1Password mode: Using specific credential IDs');
                    console.log('- Credential details:');
                    authOptions.allowCredentials.forEach((cred, index) => {
                        console.log(`  [${index}] type: ${cred.type}, id: ${cred.id?.constructor?.name || 'unknown'} (length: ${cred.id?.length || 'N/A'})`);
                        if (cred.id && cred.id.length > 0) {
                            console.log(`  [${index}] first 4 bytes: [${Array.from(cred.id.slice(0, 4)).join(', ')}]`);
                        }
                    });
                } else {
                    console.log('- Discoverable credentials mode: Empty allowCredentials');
                }
                
                // Check cross-domain setup if rpId differs from current origin
                if (authOptions.rpId !== window.location.hostname) {
                    console.log(`Cross-domain WebAuthn: ${window.location.hostname} -> ${authOptions.rpId}`);
                    
                    // Check if well-known file is accessible
                    const wellKnownUrl = `https://${authOptions.rpId}/.well-known/webauthn`;
                    console.log('Checking well-known file:', wellKnownUrl);
                    
                    try {
                        const wellKnownResponse = await fetch(wellKnownUrl, {
                            mode: 'cors',
                            headers: {
                                'Accept': 'application/json'
                            }
                        });
                        if (wellKnownResponse.ok) {
                            const wellKnownData = await wellKnownResponse.json();
                            console.log('Well-known data:', wellKnownData);
                            
                            // Check if current origin is in the allowed origins
                            const currentOrigin = `https://${window.location.hostname}`;
                            if (wellKnownData.origins && wellKnownData.origins.includes(currentOrigin)) {
                                console.log('‚úÖ Current origin is allowed in well-known file');
                            } else {
                                console.warn('‚ùå Current origin NOT found in well-known file:', currentOrigin);
                                console.log('Allowed origins:', wellKnownData.origins);
                            }
                        } else {
                            console.warn('‚ö†Ô∏è Well-known file not accessible:', wellKnownResponse.status);
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Failed to fetch well-known file (CORS issue):', e.message);
                        
                        // Show user-friendly message about cross-domain issues
                        showStatus('‚ö†Ô∏è Cross-domain CORS issue detected. Trying to proceed anyway...', 'warning');
                    }
                }
                
                showStatus('üëÜ Please authenticate with your passkey...<br><small>üí° If 1Password doesn\'t appear on desktop, try using your phone to scan this page!</small>');
                
                // Small delay to help with desktop 1Password compatibility
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Debug: Check what authenticators are available
                console.log('Checking available authenticators...');
                if (window.PublicKeyCredential && window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable) {
                    try {
                        const platformAuthAvailable = await window.PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
                        console.log('Platform authenticator available:', platformAuthAvailable);
                    } catch (e) {
                        console.log('Could not check platform authenticator:', e);
                    }
                }
                
                // Debug: Log the exact options being sent to WebAuthn
                console.log('WebAuthn options being sent:', JSON.stringify(authOptions, null, 2));
                
                // Check if 1Password extension is present (common detection method)
                const has1PasswordExtension = window.navigator.userAgent.includes('1Password') || 
                                            document.querySelector('meta[name="1password-extension"]') ||
                                            window.OnePasswordExtension ||
                                            document.documentElement.hasAttribute('data-1password-extension-installed');
                
                // Safari-specific 1Password detection
                const isSafari = /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent);
                let safariPasskeyMethod = 'platform'; // Default to platform authenticator
                
                if (isSafari) {
                    console.log('üß≠ Safari detected - checking passkey preferences...');
                    
                    // In Safari, both platform and 1Password can handle passkeys
                    // We'll let Safari decide which method to use based on user preference
                    console.log('Safari will present available passkey options (TouchID, 1Password, etc.)');
                    safariPasskeyMethod = 'auto';
                }
                
                console.log('1Password extension detected:', has1PasswordExtension);
                console.log('Safari passkey method:', safariPasskeyMethod);
                
                // Get credential from authenticator
                // For desktop 1Password, ensure this happens as close to user interaction as possible
                console.log('Requesting WebAuthn credential with maximum compatibility settings...');
                
                // Debug: Log the exact structure being sent to WebAuthn
                console.log('üîç Final authOptions structure:', {
                    challenge: {
                        type: authOptions.challenge.constructor.name,
                        length: authOptions.challenge.length,
                        sample: Array.from(authOptions.challenge.slice(0, 8))
                    },
                    timeout: {
                        type: typeof authOptions.timeout,
                        value: authOptions.timeout
                    },
                    rpId: {
                        type: typeof authOptions.rpId,
                        value: authOptions.rpId
                    },
                    userVerification: {
                        type: typeof authOptions.userVerification,
                        value: authOptions.userVerification
                    },
                    allowCredentials: {
                        type: authOptions.allowCredentials.constructor.name,
                        length: authOptions.allowCredentials.length,
                        structure: authOptions.allowCredentials.map((cred, i) => ({
                            index: i,
                            type: typeof cred.type,
                            typeValue: cred.type,
                            id: {
                                type: cred.id.constructor.name,
                                length: cred.id.length
                            }
                        }))
                    }
                });
                
                let credential;
                try {
                    // 1Password Desktop Extension Compatibility Enhancements
                    console.log('üéØ Initiating WebAuthn with 1Password compatibility mode...');
                    
                    // Desktop 1Password needs more time to initialize
                    if (onePasswordInfo.likely1PasswordPresent && !onePasswordInfo.browser.isSafari) {
                        console.log('Desktop 1Password detected - using extended initialization delay');
                        await new Promise(resolve => setTimeout(resolve, 500));
                    } else {
                        // Standard delay for other authenticators
                        await new Promise(resolve => setTimeout(resolve, 50));
                    }
                    
                    // Log final WebAuthn request details for desktop debugging
                    console.log('üöÄ WebAuthn Request Summary:');
                    console.log('- rpId:', authOptions.rpId);
                    console.log('- allowCredentials provided:', authOptions.allowCredentials.length > 0);
                    console.log('- timeout:', authOptions.timeout);
                    console.log('- userVerification:', authOptions.userVerification);
                    if (authOptions.allowCredentials.length > 0) {
                        console.log('- credential IDs for desktop 1Password:');
                        authOptions.allowCredentials.forEach((cred, i) => {
                            console.log(`  [${i}] ${cred.type}, ${cred.id.length} bytes`);
                        });
                    }
                    
                    showStatus('üîê Calling WebAuthn API - Safari will present available passkey options...');
                    
                    console.log('üéØ About to call navigator.credentials.get for MANUAL authentication...');
                    console.log('üîß navigator.credentials available:', !!navigator.credentials);
                    console.log('üîß navigator.credentials.get available:', typeof navigator.credentials.get);
                    
                    // Add timeout wrapper to catch hanging calls
                    const webauthnPromise = navigator.credentials.get({
                        publicKey: authOptions
                        // NO mediation parameter for manual authentication - this is user-initiated
                    });
                    
                    console.log('üöÄ Manual WebAuthn promise created, waiting for response...');
                    
                    // Race against timeout to detect hanging
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error('MANUAL WebAuthn call timed out after 10 seconds')), 10000);
                    });
                    
                    try {
                        credential = await Promise.race([webauthnPromise, timeoutPromise]);
                        console.log('‚úÖ Manual WebAuthn success! Credential received:', credential?.id || 'unknown');
                    } catch (raceError) {
                        console.error('üö® Manual WebAuthn race error:', raceError.message);
                        // Try to get the original promise result anyway
                        try {
                            console.log('üîÑ Attempting to resolve original manual promise...');
                            credential = await webauthnPromise;
                            console.log('‚úÖ Late manual WebAuthn success:', credential?.id || 'unknown');
                        } catch (originalError) {
                            console.error('üí• Original manual WebAuthn error:', originalError);
                            throw originalError;
                        }
                    }
                    
                } catch (webauthnError) {
                    console.error('‚ùå WebAuthn error:', webauthnError);
                    console.error('Error details:', {
                        name: webauthnError.name,
                        message: webauthnError.message,
                        stack: webauthnError.stack
                    });
                    
                    // Enhanced 1Password-specific error handling
                    if (webauthnError.name === 'NotAllowedError') {
                        if (onePasswordInfo.likely1PasswordPresent) {
                            throw new Error('1Password desktop extension not responding. Try: 1) Refresh page and try again, 2) Check if 1Password extension is enabled, 3) Use mobile device to scan QR code, or 4) Update 1Password extension.');
                        } else {
                            throw new Error('Authentication cancelled or 1Password extension not detected. Please install 1Password browser extension or use a mobile device.');
                        }
                    } else if (webauthnError.name === 'AbortError') {
                        throw new Error('Authentication timed out. This often happens when 1Password doesn\'t have matching credentials for this site. Try registering a new passkey first.');
                    }
                    
                    // Handle specific desktop compatibility issues
                    if (webauthnError.name === 'TypeError') {
                        console.error('TypeError in WebAuthn - likely invalid data format');
                        console.error('AuthOptions that caused error:', authOptions);
                        throw new Error('WebAuthn data format error - check browser console for details. This usually indicates invalid credential ID format or malformed authentication options.');
                    } else if (webauthnError.name === 'NotSupportedError') {
                        throw new Error('WebAuthn not supported. This might mean: 1) 1Password extension not installed/enabled, 2) Browser doesn\'t support WebAuthn, or 3) No compatible authenticators available.');
                    } else if (webauthnError.name === 'NotAllowedError') {
                        throw new Error('Authentication was cancelled or not allowed. This could mean: 1) User cancelled, 2) No user gesture detected, 3) 1Password extension not responding, or 4) No matching credentials found.');
                    } else if (webauthnError.name === 'SecurityError') {
                        throw new Error('Security error - this might be a cross-domain issue or browser security policy blocking the request.');
                    } else if (webauthnError.name === 'AbortError') {
                        throw new Error('Authentication was aborted. This often happens when 1Password doesn\'t have matching credentials for this site.');
                    } else {
                        throw new Error(`Authentication failed: ${webauthnError.name} - ${webauthnError.message}. Try using your mobile device to scan this page.`);
                    }
                }
                
                if (!credential) {
                    throw new Error('No credential received from authenticator');
                }
                
                showStatus('üì° Verifying credential with aMember...');
                
                // Prepare credential data for API
                const credentialData = {
                    id: credential.id,
                    rawId: arrayBufferToBase64url(credential.rawId),
                    type: credential.type,
                    response: {
                        clientDataJSON: arrayBufferToBase64url(credential.response.clientDataJSON),
                        authenticatorData: arrayBufferToBase64url(credential.response.authenticatorData),
                        signature: arrayBufferToBase64url(credential.response.signature),
                        userHandle: credential.response.userHandle ? 
                            arrayBufferToBase64url(credential.response.userHandle) : null
                    },
                    challenge: arrayBufferToBase64url(authOptions.challenge)
                };
                
                // Send credential to secure server endpoint
                const response = await fetch(SECURE_AUTH_ENDPOINT + '?action=authenticate', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        credential: credentialData
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status} ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.ok && result.access) {
                    showStatus('‚úÖ Authentication successful!', 'success');
                    displayUserInfo(result);
                } else {
                    throw new Error(result.error || 'Authentication failed');
                }
                
            } catch (error) {
                console.error('Passkey authentication error:', error);
                showStatus(`‚ùå Authentication failed: ${error.message}`, 'error');
                userInfoDiv.style.display = 'none';
            } finally {
                loginButton.disabled = false;
            }
        }

        // Display configuration settings from aMember
        function displayConfigurationSettings(config) {
            const configDisplay = document.getElementById('config-display');
            if (!configDisplay) return;
            
            const settings = [
                { label: 'Enable Passkey Login', value: config.ok ? 'Yes' : 'No' },
                { label: 'Relying Party Name', value: config.rpName || 'Not set' },
                { label: 'Relying Party ID', value: config.rpId || 'Not set' },
                { label: 'Authentication Timeout (ms)', value: config.timeout || 'Not set' },
                { label: 'User Verification Requirement', value: config.userVerification || 'Not set' },
                { label: 'Resident Key Preference', value: config.residentKey || 'Not set' },
                { label: 'Require Resident Key Support', value: config.requireResidentKey !== undefined ? (config.requireResidentKey ? 'Yes' : 'No') : 'Not set' },
                { label: 'Attestation Preference', value: config.attestation || 'Not set' },
                { label: 'Authenticator Attachment', value: config.authenticatorAttachment || 'Any' }
            ];
            
            let html = '<h3>üîß aMember WebAuthn Configuration</h3><div class="config-grid">';
            settings.forEach(setting => {
                html += `<div class="config-item"><strong>${setting.label}:</strong> ${setting.value}</div>`;
            });
            html += '</div>';
            
            if (config.relatedOrigins && config.relatedOrigins.origins) {
                html += '<h4>üåê Related Origins</h4><ul>';
                config.relatedOrigins.origins.forEach(origin => {
                    html += `<li>${origin}</li>`;
                });
                html += '</ul>';
            }
            
            configDisplay.innerHTML = html;
        }
        
        // Event listeners
        loginButton.addEventListener('click', authenticateWithPasskey);
        
        // CRITICAL: Start conditional autofill for 1Password compatibility
        // This matches the aMember plugin approach for desktop 1Password support
        async function startConditionalAutofill() {
            console.log('üîç startConditionalAutofill() called');
            
            if (!window.PublicKeyCredential || !navigator.credentials) {
                console.log('‚ùå WebAuthn not supported - skipping conditional autofill');
                return;
            }
            
            console.log('‚úÖ WebAuthn supported, proceeding with conditional autofill');
            
            try {
                console.log('üîÑ Starting conditional autofill for 1Password desktop compatibility...');
                
                // Load configuration first
                if (!passkeyConfig) {
                    console.log('‚öôÔ∏è Loading configuration for conditional autofill...');
                    const configLoaded = await loadPasskeyConfig();
                    if (!configLoaded) {
                        console.log('‚ùå Failed to load config for conditional autofill');
                        return;
                    }
                    console.log('‚úÖ Configuration loaded for conditional autofill');
                }
                
                // Create authentication options (same as manual login but for conditional autofill)
                const authOptions = {
                    challenge: crypto.getRandomValues(new Uint8Array(32)),
                    timeout: parseInt(passkeyConfig.timeout) || 60000,
                    rpId: String(passkeyConfig.rpId || window.location.hostname),
                    userVerification: String(passkeyConfig.userVerification || 'preferred'),
                    allowCredentials: [] // Empty for discoverable credentials (aMember approach)
                };
                
                console.log('üéØ Starting conditional WebAuthn request for 1Password...');
                console.log('Conditional auth options:', authOptions);
                console.log('üîß navigator.credentials available for conditional:', !!navigator.credentials);
                console.log('üîß navigator.credentials.get available for conditional:', typeof navigator.credentials.get);
                
                // Add timeout wrapper to catch hanging calls in conditional mode
                const conditionalPromise = navigator.credentials.get({
                    publicKey: authOptions,
                    mediation: "conditional"
                });
                
                console.log('üöÄ Conditional WebAuthn promise created, waiting for response...');
                
                // Race against timeout to detect hanging in conditional mode
                const conditionalTimeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('Conditional WebAuthn call timed out after 15 seconds')), 15000);
                });
                
                let credential;
                try {
                    credential = await Promise.race([conditionalPromise, conditionalTimeoutPromise]);
                    console.log('‚úÖ Conditional WebAuthn success! Credential received:', credential?.id || 'unknown');
                } catch (raceError) {
                    console.error('üö® Conditional WebAuthn race error:', raceError.message);
                    // Try to get the original promise result anyway
                    try {
                        console.log('üîÑ Attempting to resolve original conditional promise...');
                        credential = await conditionalPromise;
                        console.log('‚úÖ Late conditional WebAuthn success:', credential?.id || 'unknown');
                    } catch (originalError) {
                        console.error('üí• Original conditional WebAuthn error:', originalError);
                        throw originalError;
                    }
                }
                
                console.log('üì¶ Conditional credential result:', credential);
                
                if (credential) {
                    console.log('‚úÖ Conditional autofill credential received! Processing...');
                    
                    // Process the credential (same as manual authentication)
                    showStatus('üì° Verifying passkey credential...');
                    
                    const credentialData = {
                        id: credential.id,
                        rawId: arrayBufferToBase64url(credential.rawId),
                        type: credential.type,
                        response: {
                            clientDataJSON: arrayBufferToBase64url(credential.response.clientDataJSON),
                            authenticatorData: arrayBufferToBase64url(credential.response.authenticatorData),
                            signature: arrayBufferToBase64url(credential.response.signature),
                            userHandle: credential.response.userHandle ? 
                                arrayBufferToBase64url(credential.response.userHandle) : null
                        },
                        challenge: arrayBufferToBase64url(authOptions.challenge)
                    };
                    
                    // Send to server
                    const response = await fetch(SECURE_AUTH_ENDPOINT + '?action=authenticate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ credential: credentialData })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        if (result.ok && result.access) {
                            showStatus('‚úÖ Conditional autofill authentication successful!', 'success');
                            displayUserInfo(result);
                            loginButton.style.display = 'none'; // Hide manual login button
                        } else {
                            console.log('‚ùå Conditional autofill auth failed:', result.error);
                        }
                    } else {
                        console.log('‚ùå Conditional autofill request failed:', response.status);
                    }
                } else {
                    console.log('‚ÑπÔ∏è No credential returned from conditional autofill (this is normal)');
                }
                
            } catch (error) {
                console.log('‚ö†Ô∏è Conditional autofill error:', error.name, '-', error.message);
                console.error('Full conditional autofill error:', error);
                // This is normal - not all browsers/extensions support it
            }
        }
        
        // Handle traditional login form submission
        function handleTraditionalLogin(event) {
            event.preventDefault();
            console.log('üìù Traditional login form submitted');
            showStatus('‚ÑπÔ∏è Traditional login not implemented in this demo. Use passkey login below.', 'info');
            
            // In a real implementation, you would submit to your authentication endpoint
            // For this demo, we'll just show the passkey option
            setTimeout(() => {
                showStatus('‚ú® Ready for secure passkey authentication!', 'success');
            }, 2000);
        }
        
        // Initial setup
        document.addEventListener('DOMContentLoaded', async function() {
            const platform = getPlatformInfo();
            
            if (!window.PublicKeyCredential) {
                showStatus('‚ö†Ô∏è WebAuthn is not supported in this browser. Please use a modern browser with passkey support.', 'error');
                loginButton.disabled = true;
                return;
            }
            
            // Set up form submission handler
            const loginForm = document.getElementById('loginForm');
            if (loginForm) {
                loginForm.addEventListener('submit', handleTraditionalLogin);
            }
            
            // Load configuration automatically from aMember
            showStatus('üîÑ Initializing secure passkey authentication...', 'info');
            const configLoaded = await loadPasskeyConfig();
            
            if (configLoaded) {
                let readyMessage = '‚ú® Ready for secure passkey authentication!';
                
                // Add platform-specific guidance
                if (platform.isDesktop) {
                    if (platform.isChrome) {
                        readyMessage += '<br><small>üíª Desktop Chrome detected - ensure 1Password extension is enabled</small>';
                    } else if (platform.isSafari) {
                        readyMessage += '<br><small>üíª Desktop Safari detected - built-in passkey support available</small>';
                    } else {
                        readyMessage += '<br><small>üíª Desktop browser detected - if issues occur, try mobile scan</small>';
                    }
                } else {
                    readyMessage += '<br><small>üì± Mobile device detected - passkey authentication should work reliably</small>';
                }
                
                showStatus(readyMessage, 'success');
                
                // Start conditional autofill after a short delay (matches aMember approach)
                setTimeout(() => {
                    console.log('üöÄ Initializing conditional autofill for 1Password desktop support...');
                    startConditionalAutofill();
                }, 1000); // 1 second delay like aMember plugin
            }
        });
    </script>
</body>
</html>
